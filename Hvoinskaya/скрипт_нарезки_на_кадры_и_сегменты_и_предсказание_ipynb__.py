# -*- coding: utf-8 -*-
"""Скрипт нарезки на кадры и сегменты и предсказание.ipynb""

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IAQoPaMYRcOIdk15z1EuiCDQFxuFMGEp
"""

from google.colab import drive
drive.mount('/content/drive')
import os
import shutil
import zipfile
from sklearn.model_selection import train_test_split
import zipfile

def unzip(source_filename, dest_dir):
  with zipfile.ZipFile(source_filename) as zf:
    zf.extractall(dest_dir)

def zip_folder(folder_path, output_filename):
  """
  Compresses the specified folder into a zip file.

  Args:
    folder_path: Path to the folder to be zipped.
    output_filename: Name of the output zip file.
  """
  shutil.make_archive(output_filename, 'zip', folder_path)
  print(f"Folder '{folder_path}' zipped to '{output_filename}.zip'")

# Укажите путь к архиву .zip на Google Диске
zip_path = '/content/drive/MyDrive/weights_2109.zip'

# Укажите путь для распаковки архива
extract_path = '/content'

# Распаковка архива
unzip(zip_path, extract_path)

!pip install ultralytics

import cv2
import numpy as np
from ultralytics import YOLO
from google.colab.patches import cv2_imshow



# Загрузка модели YOLOv8
model = YOLO('/content/weights_2109/best.pt')
# Открытие видеофайла
#video_capture = cv2.VideoCapture("/content/drive/MyDrive/WhatsApp Video 2024-06-15 at 08.54.44.mp4")
video_capture = cv2.VideoCapture("/content/drive/MyDrive/Выгрузка 1.mp4")
# Получение информации о видео
frame_width = int(video_capture.get(cv2.CAP_PROP_FRAME_WIDTH))
frame_height = int(video_capture.get(cv2.CAP_PROP_FRAME_HEIGHT))
fps = video_capture.get(cv2.CAP_PROP_FPS)
print( frame_width)
print(frame_height)
print(fps)


seg_rows = 2  # Количество строк сегментов  2
seg_cols = 4  # Количество столбцов сегментов 4
target_size = (640, 640)  # Целевой размер сегмента

# Создание видео-файла для записи
output_video = cv2.VideoWriter('/content/drive/MyDrive/video/ovideo2209.mp4',
                            cv2.VideoWriter_fourcc(*'mp4v'),
                            fps,
                            (640, 640))


frame_count = 0
while video_capture.isOpened():
    # Чтение кадра из видео
    success, frame = video_capture.read()
    if not success:
      print("Не смогли прочитать кадр")
      break
    # Обрабатываем каждый n-ый кадр
    #if frame_count % n_frame == 0:
    #if frame_count % n_frame != 0:
    #  continue

    h, w, _ = frame.shape  # Получаем размеры кадра

    # Размеры каждого сегмента
    seg_h, seg_w = h // seg_rows, w // seg_cols



    mosaic_frame = np.zeros((target_size[1], target_size[0], 3), dtype=np.uint8)  # Общий кадр для всех сегментов

    # Разделяем кадр на сегменты и сохраняем их
    for row in range(seg_rows):
       for col in range(seg_cols):
          # Координаты сегмента
          x_start, x_end = col * seg_w, (col + 1) * seg_w
          y_start, y_end = row * seg_h, (row + 1) * seg_h

          # Вырезаем сегмент
          segment = frame[y_start:y_end, x_start:x_end]

          # Масштабируем сегмент до 640x640
          segment_resized = cv2.resize(segment, target_size)

          # Детекция объектов
          results = model(segment_resized, conf=0.5)

          # Сохранение результата в виде numpy_array
          annotated_frame = results[0].plot()

          # Размеры каждого сегмента annotated_frame
          ss_h, ss_w = target_size[1] // seg_rows, target_size[0] // seg_cols
          resized_annotated_frame = cv2.resize(annotated_frame, (ss_w, ss_h))  # Размеры сегмента

          mosaic_x_start = col * (target_size[0] // seg_cols)
          mosaic_y_start = row * (target_size[1] // seg_rows)

          mosaic_frame[mosaic_y_start:mosaic_y_start + ss_h,
                       mosaic_x_start:mosaic_x_start + ss_w] = resized_annotated_frame

          #print(f"row={row}  col={col} mosaic_x_start={mosaic_x_start} mosaic_y_start={mosaic_y_start} {resized_annotated_frame.shape}  {mosaic_frame.shape}")
    output_video.write( mosaic_frame )
    #cv2_imshow( mosaic_frame )
    frame_count = frame_count + 1
    if frame_count>380:
      break
    video_capture.set(cv2.CAP_PROP_POS_FRAMES, frame_count*10)




# Освободить захват и закрыть окно
video_capture.release()
output_video.release()
cv2.destroyAllWindows()

from moviepy.editor import VideoFileClip

video = VideoFileClip('/content/drive/MyDrive/video/ovideo2209.mp4')
video.ipython_display(width=500, center=False)